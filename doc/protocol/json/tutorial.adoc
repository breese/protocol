///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2017 Bjorn Reese <breese@users.sourceforge.net>
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
///////////////////////////////////////////////////////////////////////////////

[#protocol-json-tutorial]
=== Tutorial: Serialization

This tutorial shows how JSON serialization archives can be used to serialize
and deserialize C++ data types in just a few lines of code.

[.lead]
POD Serialization

Let us start by serializing some plain old data.
First we include some headers:
[source]
----
#include <trial/protocol/buffer/string.hpp> // Use std::string as output buffer
#include <trial/protocol/json/serialization.hpp>
----

The `<trial/protocol/json/serialization.hpp>` header is needed to get the
<<protocol-json-oarchive,JSON output archive>> that converts our data into
JSON.
The `json::oarchive` constructor takes an <<protocol-buffer,output buffer>>,
and because we want to serialize the result into a `std::string` we must
include an appropriate wrapper from the `<trial/protocol/buffer/string.hpp>`
header. If our output buffer had been of a different type, then we should have
included another header.

Next we serialize our data:
[source]
----
// Build data
const bool data = true;

// Serialization
std::string json;
trial::protocol::json::oarchive output(json);
output << data;
----
The `json` string now contains the formatted JSON output.
[source]
----
assert(json == "true");
----

We can deserialize this result again with the <<protocol-json-iarchive,JSON input archive>>.
[source]
----
bool result = false;
trial::protocol::json::iarchive input(json);
input >> result;

assert(result == data);
----

[.lead]
Non-intrusive Serialization

There is built-in support for serialization of certain STL containers.
The following example shows how to serialize an `std::map`.
In addition to the previously mentioned headers, we also include headers to
serialize both `std::string` and `std::map`.

[source]
----
#include <trial/protocol/buffer/string.hpp>
#include <trial/protocol/json/serialization.hpp>
----
The serialization code is exactly the same as in the previous example.
[source]
----
// Build data
std::map<std::string, std::string> data;
data["alpha"] = "hydrogen";
data["bravo"] = "helium";

// Serialization
std::string output;
trial::protocol::json::oarchive archive(output);
archive << data;

assert(output == "{\"alpha\":\"hydrogen\",\"bravo\":\"helium\"}");
----

=== Tutorial: Push Parser

In this tutorial we are going to use the incremental parser to build another
kind of parser. This other kind of parser is also referred to as incremental,
so we introduce a distinction between incremental pull parsers and incremental
push parsers. The main difference between these two kinds of parser are the
direction of control. With pull parsers the user extracts or pulls one token
after another, whereas with push parser the tokens are automatically pushed
to the user via callback functions.

The incremental parsers supplied by Trial.Protocol are pull parsers. Pull
parsers are well-suited to create other kinds of parser interfaces. In this
tutorial we shall use pull parsers to create push parsers. The serialization
archives from the previous tutorial are also build around pull parsers.

// FIXME: Start with simple pull parser examples before creating the push parser

<<protocol-json-reader,`json::reader`>> is a pull parser that lazily parses a
single token in the input. The `json::reader::next()` function is used to
advance the cursor to the next token. This tutorial demonstrates how
`json::reader` can be used to create a push parser.

A push parser iterates over the JSON input and invokes callback functions for
each parsed data item. Each data type has a distinct callback function. The
user provides the implemention of these callback functions. The design is a
variation of the http://en.wikipedia.org/wiki/Builder_pattern[Builder pattern],
and this is how XML http://en.wikipedia.org/wiki/Simple_API_for_XML[SAX] parsers
work.

[.lead]
Definitions

First we define the `push_parser` class which takes the callback functions as
a template parameter.footnote:[We could also have used a polymorphic interface
for the callback functions.]
[source]
----
#include <trial/protocol/json/reader.hpp>

namespace json = trial::protocol::json;

template <typename Callbacks>
class push_parser
{
public:
    push_parser(const json::reader& reader) : reader(reader) {}

    void parse();

private:
    Callbacks callbacks;
    json::reader reader;
};
----
The `Callbacks` template parameter must be a class that implements a member
function for each callback function. The `Callbacks` class could look something
like this:
[source]
----
#include <cstdint>
#include <string>

class my_callbacks
{
public:
    void on_null();
    void on_boolean(bool);
    void on_integer(std::intmax_t);
    void on_number(double);
    void on_string(const std::string&);
    void on_begin_array();
    void on_end_array();
    void on_begin_object();
    void on_end_object();
};
----
We are not going to implement `my_callbacks` here, although a simple
implementation could be to simply print the type and value in each callback
function.

[.lead]
Execution

After these preliminary definitions, we have now arrived at the crux of the
problem: how to implement the `push_parser::parse()` function.
As this is a demonstration of the <<protocol-json-reader,`json::reader`>>,
we are naturally going to implement the push parser with a pull parser.
Fortunately that is very simple:

. Iterate over the JSON input using `json::reader::next()`.
.. Identify the current token with `json::reader::symbol()`.
.. Invoke the appropriate callback function.
   The current value for data tokens is obtained with `json::reader::value<T>()`.
      
Here is the entire implementation in its full glory:
[source]
----
void push_parser::parse()
{
    do
    {
        switch (reader.symbol())
        {
        case json::symbol::null:
            callbacks.on_null();
            break;

        case json::symbol::boolean:
            callbacks.on_boolean(reader.value<bool>());
            break;

        case json::symbol::integer:
            callbacks.on_integer(reader.value<std::intmax_t>());
            break;

        case json::symbol::number:
            callbacks.on_number(reader.value<double>());
            break;

        case json::symbol::string:
            callbacks.on_string(reader.value<std::string>());
            break;

        case json::symbol::begin_array:
            callbacks.on_begin_array();
            break;

        case json::symbol::end_array:
            callbacks.on_end_array();
            break;

        case json::symbol::begin_object:
            callbacks.on_begin_object();
            break;

        case json::symbol::end_object:
            callbacks.on_end_object();
            break;

        default:
            break;
        }

    } while (reader.next());
}
----

Finally, we use the above push parser as follows:
[source]
----
json::reader reader("[null,true,42]"); // Replace with actual JSON input
push_parser<my_callbacks> parser(reader);
parser.parse();
----
